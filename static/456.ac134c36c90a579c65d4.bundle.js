webpackJsonp([456],{1501:function(module,exports){module.exports="import React, {Component} from 'react';\nimport PropTypes from 'prop-types';\nimport s from './DataTable.scss';\nimport classNames from 'classnames';\nimport InfiniteScroll from './InfiniteScroll';\nimport WixComponent from '../BaseComponents/WixComponent';\nimport ArrowVertical from '../Icons/dist/components/ArrowVertical';\nimport {Animator} from 'wix-animations';\n\nexport const DataTableHeader = props => (\n  <div>\n    <table style={{width: props.width}} className={s.table}>\n      <TableHeader {...props}/>\n    </table>\n  </div>\n);\n\nDataTableHeader.propTypes = {\n  width: PropTypes.number\n};\n\nclass DataTable extends WixComponent {\n  constructor(props) {\n    super(props);\n    let state = {selectedRows: {}};\n    if (props.infiniteScroll) {\n      state = {...state, ...this.createInitialScrollingState(props)};\n    }\n    this.state = state;\n  }\n\n  componentWillReceiveProps(nextProps) {\n    let isLoadingMore = false;\n    if (this.props.infiniteScroll && nextProps.data !== this.props.data) {\n      if (nextProps.data instanceof Array && this.props.data instanceof Array) {\n        if (this.props.data.every((elem, index) => {\n          return nextProps.data.length > index && nextProps.data[index] === elem;\n        })) {\n          isLoadingMore = true;\n          this.setState({lastPage: this.calcLastPage(nextProps)});\n        }\n      }\n      if (!isLoadingMore) {\n        this.setState(this.createInitialScrollingState(nextProps));\n      }\n    }\n  }\n\n  createInitialScrollingState(props) {\n    return {currentPage: 0, lastPage: this.calcLastPage(props)};\n  }\n\n  render() {\n    const {data, showHeaderWhenEmpty, infiniteScroll, itemsPerPage} = this.props;\n\n    if (!data.length && !showHeaderWhenEmpty) {\n      return null;\n    }\n\n    const rowsToRender = infiniteScroll ?\n      data.slice(0, ((this.state.currentPage + 1) * itemsPerPage)) :\n      data;\n\n    const table = this.renderTable(rowsToRender);\n\n    if (infiniteScroll) {\n      return this.wrapWithInfiniteScroll(table);\n    }\n\n    return table;\n  }\n\n  wrapWithInfiniteScroll = table => {\n    return (\n      <InfiniteScroll\n        pageStart={0}\n        loadMore={this.loadMore}\n        hasMore={this.state.currentPage < this.state.lastPage || (this.props.hasMore)}\n        loader={this.props.loader}\n        useWindow={this.props.useWindow}\n        scrollElement={this.props.scrollElement}\n        >\n        {table}\n      </InfiniteScroll>\n    );\n  };\n\n  renderTable = rowsToRender => {\n    const style = {width: this.props.width};\n    return (\n      <div>\n        <table id={this.props.id} style={style} className={s.table}>\n          {!this.props.hideHeader &&\n          <TableHeader {...this.props}/>}\n          {this.renderBody(rowsToRender)}\n        </table>\n      </div>);\n  };\n\n  renderBody = rows => (\n    <tbody>\n      {rows.map(this.renderRow)}\n    </tbody>\n  );\n\n  onRowClick = (rowData, rowNum) => {\n    const {onRowClick, rowDetails} = this.props;\n    onRowClick && onRowClick(rowData, rowNum);\n    rowDetails && this.toggleRowDetails(rowNum);\n  }\n\n  renderRow = (rowData, rowNum) => {\n    const {onRowClick, onMouseEnterRow, onMouseLeaveRow, rowDataHook, dynamicRowClass, rowDetails} = this.props;\n    const rowClasses = [this.props.rowClass];\n    const optionalRowProps = {};\n\n    const handlers = [\n      {rowEventHandler: this.onRowClick, eventHandler: 'onClick'},\n      {rowEventHandler: onMouseEnterRow, eventHandler: 'onMouseEnter'},\n      {rowEventHandler: onMouseLeaveRow, eventHandler: 'onMouseLeave'}\n    ];\n\n    handlers.forEach(({rowEventHandler, eventHandler}) => {\n      if (rowEventHandler) {\n        optionalRowProps[eventHandler] = event => {\n          if (event.isDefaultPrevented()) {\n            return;\n          }\n          rowEventHandler(rowData, rowNum);\n        };\n      }\n    });\n\n    if (onRowClick || rowDetails) {\n      rowClasses.push(s.clickableDataRow);\n    }\n\n    if (rowDataHook) {\n      if (typeof rowDataHook === 'string') {\n        optionalRowProps['data-hook'] = rowDataHook;\n      } else {\n        optionalRowProps['data-hook'] = rowDataHook(rowData, rowNum);\n      }\n    }\n\n    if (dynamicRowClass) {\n      rowClasses.push(dynamicRowClass(rowData, rowNum));\n    }\n\n    optionalRowProps.className = classNames(rowClasses);\n\n    const rowsToRender = [(\n      <tr data-table-row=\"dataTableRow\" key={rowNum} {...optionalRowProps}>\n        {this.props.columns.map((column, colNum) => this.renderCell(rowData, column, rowNum, colNum))}\n      </tr>\n    )];\n\n    if (rowDetails) {\n      const showDetails = !!this.state.selectedRows[rowNum];\n\n      rowsToRender.push(\n        <tr key={`${rowNum}_details`} className={classNames(s.rowDetails)}>\n          <td\n            data-hook={`${rowNum}_details`} className={classNames(s.details, showDetails ? s.active : '')}\n            colSpan={this.props.columns.length}\n            >\n            <div className={classNames(s.rowDetailsInner)}>\n              <Animator show={showDetails} height>\n                {rowDetails(rowData, rowNum)}\n              </Animator>\n            </div>\n          </td>\n        </tr>\n      );\n    }\n\n    return rowsToRender;\n  };\n\n  renderCell = (rowData, column, rowNum, colNum) => {\n    const classes = classNames({[s.important]: column.important});\n    return (<td\n      style={column.style} className={classes}\n      key={colNum}\n      >\n      {column.render && column.render(rowData, rowNum)}\n    </td>);\n  };\n\n  calcLastPage = ({data, itemsPerPage}) => Math.ceil(data.length / itemsPerPage) - 1;\n\n  loadMore = () => {\n    if (this.state.currentPage < this.state.lastPage) {\n      this.setState({currentPage: this.state.currentPage + 1});\n    } else {\n      this.props.loadMore && this.props.loadMore();\n    }\n  }\n\n  toggleRowDetails = selectedRow => {\n    let selectedRows = {[selectedRow]: !this.state.selectedRows[selectedRow]};\n    if (this.props.allowMultiDetailsExpansion) {\n      selectedRows = Object.assign({}, this.state.selectedRows, {[selectedRow]: !this.state.selectedRows[selectedRow]});\n    }\n    this.setState({selectedRows});\n  }\n}\n\nclass TableHeader extends Component {\n  static propTypes = {\n    onSortClick: PropTypes.func,\n    thPadding: PropTypes.string,\n    thHeight: PropTypes.string,\n    thFontSize: PropTypes.string,\n    thBorder: PropTypes.string,\n    thColor: PropTypes.string,\n    thOpacity: PropTypes.string,\n    thLetterSpacing: PropTypes.string,\n    columns: PropTypes.array\n  };\n\n  renderSortingArrow = (sortDescending, colNum) => {\n    if (sortDescending === undefined) {\n      return null;\n    }\n    const sortDirectionClassName = sortDescending ? s.sortArrowAsc : s.sortArrowDesc;\n    return <span data-hook={`${colNum}_title`} className={sortDirectionClassName}><ArrowVertical/></span>;\n  };\n\n  renderHeaderCell = (column, colNum) => {\n    const style = {\n      width: column.width,\n      padding: this.props.thPadding,\n      height: this.props.thHeight,\n      fontSize: this.props.thFontSize,\n      border: this.props.thBorder,\n      color: this.props.thColor,\n      opacity: this.props.thOpacity,\n      letterSpacing: this.props.thLetterSpacing,\n      cursor: column.sortable === undefined ? 'arrow' : 'pointer'\n    };\n\n    const optionalHeaderCellProps = {};\n    if (column.sortable) {\n      optionalHeaderCellProps.onClick = () => this.props.onSortClick && this.props.onSortClick(column, colNum);\n    }\n    return (\n      <th\n        style={style}\n        key={colNum}\n        {...optionalHeaderCellProps}\n        >\n        {column.title}{this.renderSortingArrow(column.sortDescending, colNum)}\n      </th>);\n  };\n\n  render() {\n    return (\n      <thead>\n        <tr>\n          {this.props.columns.map(this.renderHeaderCell)}\n        </tr>\n      </thead>);\n  }\n}\n\nfunction validateData(props, propName) {\n  if (props[propName]) {\n    if (props[propName].constructor && props[propName].constructor.name && props[propName].constructor.name.toLowerCase().indexOf('array') > -1) {\n      return null;\n    } else {\n      return Error('Data element must be an array type');\n    }\n  }\n  return null;\n}\n\nDataTable.defaultProps = {\n  data: [],\n  columns: [],\n  showHeaderWhenEmpty: false,\n  infiniteScroll: false,\n  itemsPerPage: 20,\n  width: '100%',\n  loadMore: null,\n  hasMore: false,\n  loader: <div className=\"loader\">Loading ...</div>,\n  scrollElement: null,\n  useWindow: true,\n  thPadding: '5px',\n  thHeight: '36px',\n  thFontSize: '12px'\n};\n\nDataTable.propTypes = {\n  id: PropTypes.string,\n  data: validateData,\n  columns: PropTypes.arrayOf(PropTypes.shape({\n    title: PropTypes.oneOfType([\n      PropTypes.node,\n      PropTypes.string\n    ]).isRequired,\n    render: PropTypes.func.isRequired,\n    sortable: PropTypes.bool,\n    sortDescending: PropTypes.bool\n  })),\n  showHeaderWhenEmpty: PropTypes.bool,\n  rowDataHook: PropTypes.oneOfType([\n    PropTypes.func,\n    PropTypes.string\n  ]),\n  rowClass: PropTypes.string,\n  dynamicRowClass: PropTypes.func,\n  onRowClick: PropTypes.func,\n  onMouseEnterRow: PropTypes.func,\n  onMouseLeaveRow: PropTypes.func,\n  infiniteScroll: PropTypes.bool,\n  itemsPerPage: PropTypes.number,\n  width: PropTypes.string,\n  loadMore: PropTypes.func,\n  hasMore: PropTypes.bool,\n  loader: PropTypes.node,\n  useWindow: PropTypes.bool,\n  scrollElement: PropTypes.object,\n  thPadding: PropTypes.string,\n  thHeight: PropTypes.string,\n  thFontSize: PropTypes.string,\n  thBorder: PropTypes.string,\n  thColor: PropTypes.string,\n  thOpacity: PropTypes.string,\n  thLetterSpacing: PropTypes.string,\n  rowDetails: PropTypes.func,\n  allowMultiDetailsExpansion: PropTypes.bool,\n  hideHeader: PropTypes.bool\n};\n\nDataTable.displayName = 'DataTable';\n\nexport default DataTable;\n"}});