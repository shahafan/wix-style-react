webpackJsonp([299],{1658:function(module,exports){module.exports="import React from 'react';\nimport sinon from 'sinon';\n\nimport inputDriverFactory from './Input.driver';\nimport Input from '.';\nimport {createDriverFactory} from '../test-common';\nimport {inputTestkitFactory, tooltipTestkitFactory} from '../../testkit';\nimport {inputTestkitFactory as enzymeInputTestkitFactory} from '../../testkit/enzyme';\nimport {isTestkitExists, isEnzymeTestkitExists} from '../../testkit/test-common';\nimport {makeControlled} from '../../test/utils/utils';\n\ndescribe('Input', () => {\n  const createDriver = createDriverFactory(inputDriverFactory);\n  const ControlledInput = makeControlled(Input);\n\n  describe('test tooltip', () => {\n    const resolveIn = timeout =>\n      new Promise(resolve => {\n        setTimeout(() => {\n          resolve({});\n        }, timeout);\n      });\n\n    it('should dispaly the error tooltip on hover', () => {\n      const driver = createDriver(<Input error errorMessage=\"I'm the error message\"/>);\n      const dataHook = driver.getTooltipDataHook();\n      const wrapper = driver.getTooltipElement();\n      const tooltipDriver = tooltipTestkitFactory({wrapper, dataHook});\n      tooltipDriver.mouseEnter();\n\n      return resolveIn(500).then(() => {\n        expect(tooltipDriver.getContent()).toBe('I\\'m the error message');\n      });\n    });\n\n    describe('tooltipPlacement attribute', () => {\n      ['top', 'bottom', 'left', 'right'].forEach(placement => {\n        it(`should have a tooltip positioned to the ${placement}`, () => {\n          const driver = createDriver(<Input error errorMessage=\"I'm the error message\" theme=\"amaterial\" tooltipPlacement={placement}/>);\n          const dataHook = driver.getTooltipDataHook();\n          const wrapper = driver.getTooltipElement();\n          const tooltipDriver = tooltipTestkitFactory({wrapper, dataHook});\n          tooltipDriver.mouseEnter();\n\n          return resolveIn(500).then(() => {\n            expect(tooltipDriver.getPlacement()).toBe(placement);\n          });\n        });\n      });\n    });\n\n    describe('onTooltipShow attribute (only for amaterial theme for now)', () => {\n      it('should be called when error tooltip is active', () => {\n        const onTooltipShow = sinon.spy();\n\n        const driver = createDriver(<Input theme=\"amaterial\" error errorMessage=\"I'm the error message\" onTooltipShow={onTooltipShow}/>);\n        const dataHook = driver.getTooltipDataHook();\n        const wrapper = driver.getTooltipElement();\n        const tooltipDriver = tooltipTestkitFactory({wrapper, dataHook});\n        tooltipDriver.mouseEnter();\n\n        return resolveIn(500).then(() => {\n          expect(onTooltipShow.calledOnce).toBeTruthy();\n        });\n      });\n\n      it('should be called when help tooltip is active (only for amaterial theme for now)', () => {\n        const onTooltipShow = sinon.spy();\n\n        const driver = createDriver(<Input theme=\"amaterial\" help helpMessage=\"I'm the help message\" onTooltipShow={onTooltipShow}/>);\n        const dataHook = driver.getTooltipDataHook();\n        const wrapper = driver.getTooltipElement();\n        const tooltipDriver = tooltipTestkitFactory({wrapper, dataHook});\n        tooltipDriver.mouseEnter();\n\n        return resolveIn(500).then(() => {\n          expect(onTooltipShow.calledOnce).toBeTruthy();\n        });\n      });\n    });\n  });\n\n  describe('value attribute', () => {\n    it('should pass down to the wrapped input', () => {\n      const props = {\n        value: 'hello',\n        onChange: () => {}\n      };\n\n      const driver = createDriver(<Input {...props}/>);\n      expect(driver.getValue()).toEqual(props.value);\n    });\n  });\n\n  describe('defaultValue attribute', () => {\n    it('should pass down to the wrapped input', () => {\n      const defaultValue = 'hello';\n\n      const driver = createDriver(<Input defaultValue={defaultValue}/>);\n      expect(driver.getDefaultValue()).toEqual(defaultValue);\n    });\n  });\n\n  describe('tabIndex attribute', () => {\n    it('should pass down to the wrapped input', () => {\n      const tabIndex = 1;\n\n      const driver = createDriver(<Input tabIndex={tabIndex}/>);\n      expect(driver.getTabIndex()).toEqual(tabIndex);\n    });\n  });\n\n  describe('autocomplete attribute', () => {\n    it('should pass down to the wrapped input', () => {\n      const autocomplete = 'off';\n\n      const driver = createDriver(<Input autocomplete={autocomplete}/>);\n      expect(driver.getAutocomplete()).toEqual(autocomplete);\n    });\n  });\n\n  describe('readOnly attribute', () => {\n    it('should pass down to the wrapped input', () => {\n      const driver = createDriver(<Input readOnly/>);\n      expect(driver.getReadOnly()).toBeTruthy();\n    });\n\n    it('should pass down to the wrapped input with default false value', () => {\n      const driver = createDriver(<Input/>);\n      expect(driver.getReadOnly()).toBeFalsy();\n    });\n  });\n\n  describe('textOverflow attribute', () => {\n    it('should pass down to the wrapped input', () => {\n      const driver = createDriver(<Input textOverflow=\"ellipsis\"/>);\n      expect(driver.getTextOverflow()).toBe('ellipsis');\n    });\n\n    it('should pass down to the wrapped input with default clip value', () => {\n      const driver = createDriver(<Input/>);\n      expect(driver.getTextOverflow()).toBe('clip');\n    });\n  });\n\n  describe('type attribute', () => {\n    it('should set the type attribute', () => {\n      const driver = createDriver(<Input type=\"number\"/>);\n      expect(driver.getType()).toBe('number');\n    });\n  });\n\n  describe('error attribute', () => {\n    it('should display an error icon if error is true', () => {\n      const driver = createDriver(<Input error/>);\n\n      expect(driver.hasExclamation()).toBeTruthy();\n      expect(driver.hasError()).toBeTruthy();\n    });\n  });\n\n  describe('help attribute', () => {\n    it('should display an help icon if help is true', () => {\n      const driver = createDriver(<Input help/>);\n\n      expect(driver.hasHelp()).toBeTruthy();\n    });\n  });\n\n  describe('unit attribute', () => {\n    it('should the unit text if passed', () => {\n      const unit = '$';\n\n      const driver = createDriver(<Input unit={unit}/>);\n      expect(driver.getUnit()).toEqual(unit);\n    });\n  });\n\n  describe('magnifyingGlass attribute', () => {\n    it('should display a magnifying glass icon if magnifyingGlass is true', () => {\n      const driver = createDriver(<Input magnifyingGlass/>);\n      expect(driver.hasMagnifyingGlass()).toBeTruthy();\n    });\n\n    it('should not display a magnifying glass icon if magnifyingGlass is false', () => {\n      const driver = createDriver(<Input magnifyingGlass={false}/>);\n      expect(driver.hasMagnifyingGlass()).toBeFalsy();\n    });\n\n    it('should not display a magnifying glass icon if error is true', () => {\n      const driver = createDriver(<Input magnifyingGlass error/>);\n      expect(driver.hasMagnifyingGlass()).toBeFalsy();\n    });\n  });\n\n  describe('menuArrow attribute', () => {\n    it('should display a menu arrow icon if menuArrow is true', () => {\n      const driver = createDriver(<Input menuArrow/>);\n      expect(driver.hasMenuArrow()).toBeTruthy();\n    });\n\n    it('should not display a menu arrow icon if menuArrow is false', () => {\n      const driver = createDriver(<Input menuArrow={false}/>);\n      expect(driver.hasMenuArrow()).toBeFalsy();\n    });\n\n    it('should not display a menu arrow icon if error is true', () => {\n      const driver = createDriver(<Input menuArrow error/>);\n      expect(driver.hasMenuArrow()).toBeFalsy();\n    });\n\n    it('should not display a menu arrow icon if magnifyingGlass is true', () => {\n      const driver = createDriver(<Input menuArrow magnifyingGlass/>);\n      expect(driver.hasMenuArrow()).toBeFalsy();\n    });\n  });\n\n  describe('rtl attribute', () => {\n    it('should have rtl if rtl prop is true', () => {\n      const driver = createDriver(<Input rtl/>);\n      expect(driver.isRTL()).toBeTruthy();\n    });\n\n    it('should not have rtl if rtl prop is false', () => {\n      const driver = createDriver(<Input rtl={false}/>);\n      expect(driver.isRTL()).toBeFalsy();\n    });\n  });\n\n  describe('onChange attribute', () => {\n    it('should be called when text is entered to the input', () => {\n\n      const onChange = jest.fn();\n      const event = {target: {value: 'world'}};\n\n      const driver = createDriver(<Input onChange={onChange}/>);\n\n      driver.trigger('change', event);\n\n      expect(onChange).toBeCalled();\n    });\n  });\n\n  describe('onKeyUp attribute', () => {\n    it('should be called after keybord key got pressed and then released', () => {\n      const onKeyUp = jest.fn();\n      const event = {target: {value: 'world'}};\n\n      const driver = createDriver(<Input onKeyUp={onKeyUp}/>);\n\n      driver.trigger('keyUp', event);\n\n      expect(onKeyUp).toBeCalled();\n    });\n  });\n\n  describe('onFocus attribute', () => {\n    it('should be called when the input gets focused', () => {\n      const onFocus = jest.fn();\n      const driver = createDriver(<Input onFocus={onFocus}/>);\n\n      driver.trigger('focus');\n\n      expect(onFocus).toBeCalled();\n    });\n  });\n\n  describe('onBlur attribute', () => {\n    it('should be called when the input gets blured', () => {\n      const onBlur = jest.fn();\n      const driver = createDriver(<Input onBlur={onBlur}/>);\n\n      driver.trigger('blur');\n\n      expect(onBlur).toBeCalled();\n    });\n  });\n\n  describe('onKeyDown attribute', () => {\n    it('should be called when text is entered to the wrapped input', () => {\n      const onKeyDown = jest.fn();\n      const event = {keyCode: 40};\n\n      const driver = createDriver(<Input onKeyDown={onKeyDown}/>);\n\n      driver.trigger('keyDown', event);\n\n      expect(onKeyDown).toBeCalled();\n    });\n  });\n\n  describe('onPaste attribute', () => {\n    it('should be called when pasting text to the input', () => {\n      const onPaste = jest.fn();\n\n      const driver = createDriver(<Input onPaste={onPaste}/>);\n\n      driver.trigger('paste');\n\n      expect(onPaste).toBeCalled();\n    });\n  });\n\n  describe('forceFocus attribute', () => {\n    it('should have focus class on input if forceFocus is true', () => {\n      const driver = createDriver(<Input forceFocus/>);\n      expect(driver.isFocusedStyle()).toBeTruthy();\n    });\n  });\n\n  describe('forceHover attribute', () => {\n    it('should have hover class on input if forceHover is true', () => {\n      const driver = createDriver(<Input forceHover/>);\n      expect(driver.isHoveredStyle()).toBeTruthy();\n    });\n\n    it('should be hovered if forceFocus is false and forceHover is true', () => {\n      const driver = createDriver(<Input forceHover forceFocus={false}/>);\n      expect(driver.isHoveredStyle()).toBeTruthy();\n    });\n  });\n\n  describe('disable attribute', () => {\n    it('should have disabled class on input if disabled is true', () => {\n      const driver = createDriver(<Input disabled/>);\n      expect(driver.isDisabled()).toBeTruthy();\n    });\n  });\n\n  describe('autoFocus attribute', () => {\n    it('Mounting an input element with autoFocus=false, should give it the focus', () => {\n      let autoFocus = false;\n      const driver = createDriver(<Input autoFocus={false}/>);\n      expect(driver.isFocus()).toBeFalsy();\n      autoFocus = true;\n      driver.setProps({autoFocus});\n      expect(driver.isFocus()).toBeFalsy();\n    });\n\n    it('Mounting an input element with autoFocus=true, gives it the focus', () => {\n      const driver = createDriver(<Input autoFocus/>);\n      expect(driver.isFocus()).toBeTruthy();\n    });\n  });\n\n  describe('focus function', () => {\n    it('calling focus should give focus to the input', () => {\n      const driver = createDriver(<Input autoFocus={false}/>);\n      expect(driver.isFocus()).toBeFalsy();\n      driver.focus();\n      expect(driver.isFocus()).toBeTruthy();\n    });\n  });\n\n  describe('theme attribute', () => {\n    it('should set the theme by default to \"normal\"', () => {\n      const driver = createDriver(<Input/>);\n      expect(driver.isOfStyle('normal')).toBeTruthy();\n    });\n\n    it('should allowing setting the theme to \"paneltitle\"', () => {\n      const driver = createDriver(<Input theme=\"paneltitle\"/>);\n      expect(driver.isOfStyle('paneltitle')).toBeTruthy();\n    });\n\n    it('should allow setting the theme to \"material\"', () => {\n      const driver = createDriver(<Input theme=\"material\"/>);\n      expect(driver.isOfStyle('material')).toBeTruthy();\n    });\n\n    it('should allow setting the theme to \"flat\"', () => {\n      const driver = createDriver(<Input theme=\"flat\"/>);\n      expect(driver.isOfStyle('flat')).toBeTruthy();\n    });\n\n    it('should allow setting the theme to \"flatdark\"', () => {\n      const driver = createDriver(<Input theme=\"flatdark\"/>);\n      expect(driver.isOfStyle('flatdark')).toBeTruthy();\n    });\n  });\n\n  describe('clearButton attribute', () => {\n    it('should be displayed when input text is not empty', () => {\n      const driver = createDriver(\n        <Input\n          value=\"some value\"\n          clearButton\n          />\n      );\n      expect(driver.hasClearButton()).toBe(true);\n    });\n\n    // TODO\n    it.skip('should be displayed when using uncontrolled component with defaultValue', () => {\n      const driver = createDriver(\n        <Input\n          defaultValue=\"some value\"\n          clearButton\n          />\n      );\n      expect(driver.hasClearButton()).toBe(true);\n    });\n\n    it('should not be displayed when input text is empty', () => {\n      const driver = createDriver(\n        <Input\n          value=\"\"\n          clearButton\n          />\n      );\n      expect(driver.hasClearButton()).toBe(false);\n    });\n\n    // TODO\n    it.skip('should be displayed after entering text into empty uncontrolled input', () => {\n      const driver = createDriver(\n        <Input\n          clearButton\n          />\n      );\n      driver.enterText('some value');\n      expect(driver.hasClearButton()).toBe(true);\n    });\n\n    // TODO\n    it.skip('should clear input when using uncontrolled component', () => {\n      const driver = createDriver(\n        <Input\n          clearButton\n          />\n      );\n      driver.enterText('some value');\n      driver.clickClear();\n      expect(driver.getValue()).toBe('');\n      expect(driver.isFocus()).toBe(true);\n    });\n\n    // TODO\n    it.skip('should be hidden after default value was overridden with some input', () => {\n      const driver = createDriver(\n        <Input\n          defaultValue=\"some default value\"\n          clearButton\n          />\n      );\n      expect(driver.hasClearButton()).toBe(true);\n      driver.clearText();\n      driver.enterText('new value');\n      expect(driver.hasClearButton()).toBe(false);\n    });\n\n    it('should clear input and focus it', () => {\n      const driver = createDriver(\n        <ControlledInput\n          clearButton\n          value=\"some value\"\n          />\n      );\n      driver.clickClear();\n      expect(driver.getValue()).toBe('');\n      expect(driver.isFocus()).toBe(true);\n    });\n\n    it('should trigger onChange on clearing as if input just emptied', () => {\n      const onChange = jest.fn();\n      const driver = createDriver(\n        <Input\n          onChange={onChange}\n          value=\"some value\"\n          clearButton\n          />\n      );\n      driver.clickClear();\n      expect(onChange).toBeCalled();\n      expect(onChange.mock.calls[0][0].target.value).toBe('');\n    });\n  });\n\n  describe('onClear attribute', () => {\n    it('should display clear-button when input text is not empty', () => {\n      const driver = createDriver(\n        <Input\n          value=\"some value\"\n          onClear={() => null}\n          />\n      );\n      expect(driver.hasClearButton()).toBe(true);\n    });\n\n    it('should invoke callback', () => {\n      const onClear = sinon.spy();\n      const driver = createDriver(\n        <Input\n          onClear={onClear}\n          value=\"some value\"\n          />\n      );\n      expect(driver.hasClearButton()).toBe(true);\n      driver.clickClear();\n      expect(onClear.calledOnce).toBe(true);\n    });\n  });\n\n  describe('size attribute', () => {\n    it('should use \"normal\" size by default', () => {\n      const driver = createDriver(<Input/>);\n      expect(driver.isOfSize('normal')).toBeTruthy();\n    });\n\n    it('should use \"normal-with-selection\" size if withSelection', () => {\n      const driver = createDriver(<Input size=\"normal\" withSelection/>);\n      expect(driver.isOfSize('normal-with-selection')).toBeTruthy();\n    });\n\n    it('should use \"small\" size', () => {\n      const driver = createDriver(<Input size=\"small\"/>);\n      expect(driver.isOfSize('small')).toBeTruthy();\n    });\n\n    it('should use \"large\" size', () => {\n      const driver = createDriver(<Input size=\"large\"/>);\n      expect(driver.isOfSize('large')).toBeTruthy();\n    });\n\n  });\n\n  describe('prefix attribute', () => {\n    it('should allow adding a custom prefix component', () => {\n      const driver = createDriver(<Input prefix={<div className=\"my-button\"/>}/>);\n      expect(driver.hasPrefix()).toBeTruthy();\n      expect(driver.prefixComponentExists('.my-button')).toBeTruthy();\n    });\n\n    it('should add `withPrefix` classname to input', () => {\n      const driver = createDriver(<Input prefix=\"hello\"/>);\n      expect(driver.hasPrefixClass()).toBeTruthy();\n    });\n  });\n\n  describe('suffix attribute', () => {\n    it('should allow adding a custom suffix component', () => {\n      const driver = createDriver(<Input suffix={<div className=\"my-button\"/>}/>);\n      expect(driver.hasSuffix()).toBeTruthy();\n      expect(driver.suffixComponentExists('.my-button')).toBeTruthy();\n    });\n\n    it('should add `withSuffix` classname to input', () => {\n      const driver = createDriver(<Input suffix=\"hello\"/>);\n      expect(driver.hasSuffixClass()).toBeTruthy();\n    });\n\n    it('should add `withSuffixes` classname to input when more than 1 suffix applied', () => {\n      const driver = createDriver(<Input suffix=\"hello\" magnifyingGlass/>);\n      expect(driver.hasSuffixesClass()).toBeTruthy();\n    });\n\n    it('should render menu arrow as the last suffix', () => {\n      const driver = createDriver(<Input suffix=\"hello\" menuArrow/>);\n      expect(driver.isMenuArrowLast()).toBeTruthy();\n    });\n  });\n\n  describe('aria attributes', () => {\n    it('should allow adding a custom aria-label', () => {\n      const driver = createDriver(<Input ariaLabel=\"hello\"/>);\n      expect(driver.getAriaLabel()).toBe('hello');\n    });\n\n    it('should not have any aria label buy default', () => {\n      const driver = createDriver(<Input/>);\n      expect(driver.getAriaLabel()).toBeNull;\n    });\n\n    it('should allow adding aria-controls', () => {\n      const driver = createDriver(<Input ariaControls=\"id\"/>);\n      expect(driver.getAriaControls()).toBe('id');\n    });\n\n    it('should not have any aria controls buy default', () => {\n      const driver = createDriver(<Input/>);\n      expect(driver.getAriaControls()).toBeNull;\n    });\n\n    it('should allow adding aria-controls', () => {\n      const driver = createDriver(<Input ariaDescribedby=\"blabla\"/>);\n      expect(driver.getAriaDescribedby()).toBe('blabla');\n    });\n\n    it('should not have any aria controls buy default', () => {\n      const driver = createDriver(<Input/>);\n      expect(driver.getAriaDescribedby()).toBeNull;\n    });\n\n  });\n\n});\n\ndescribe('testkit', () => {\n  it('should exist', () => {\n    const value = 'hello';\n    const onChange = () => {};\n    expect(isTestkitExists(<Input value={value} onChange={onChange}/>, inputTestkitFactory)).toBe(true);\n  });\n});\n\ndescribe('enzyme testkit', () => {\n  it('should exist', () => {\n    const value = 'hello';\n    const onChange = () => {};\n    expect(isEnzymeTestkitExists(<Input value={value} onChange={onChange}/>, enzymeInputTestkitFactory)).toBe(true);\n  });\n});\n"}});