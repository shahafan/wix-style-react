webpackJsonp([213],{1744:function(module,exports){module.exports="import React from 'react';\nimport PropTypes from 'prop-types';\nimport classNames from 'classnames';\nimport WixComponent from '../BaseComponents/WixComponent';\nimport {Editor, Block} from 'slate';\nimport Tooltip from '../Tooltip';\nimport SvgExclamation from '../svg/Exclamation.js';\nimport RichTextEditorToolbar from './RichTextAreaToolbar';\nimport htmlSerializer from './htmlSerializer';\nimport styles from './RichTextArea.scss';\nimport isImage from 'is-image';\nimport isUrl from 'is-url';\n\nconst DEFAULT_NODE = 'paragraph';\n\nconst defaultBlock = {\n  type: 'paragraph',\n  isVoid: false,\n  data: {},\n  key: 'defaultBlock'\n};\n\nclass RichTextArea extends WixComponent {\n  static propTypes = {\n    buttons: PropTypes.arrayOf(PropTypes.string), // TODO: use PropTypes.oneOf(),\n    dataHook: PropTypes.string,\n    disabled: PropTypes.bool,\n    error: PropTypes.bool,\n    errorMessage: PropTypes.string,\n    placeholder: PropTypes.string,\n    maxHeight: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n    resizable: PropTypes.bool,\n    value: PropTypes.string,\n    onChange: PropTypes.func,\n    onImageRequest: PropTypes.func\n  }\n\n  static defaultProps = {\n    errorMessage: '',\n    value: '<p></p>'\n  }\n\n  /* eslint-disable react/prop-types */\n  schema = {\n    nodes: {\n      'unordered-list': props => <ul {...props.attributes}>{props.children}</ul>,\n      'list-item': props => <li {...props.attributes}>{props.children}</li>,\n      'ordered-list': props => <ol {...props.attributes}>{props.children}</ol>,\n      link: props => {\n        const {data} = props.node;\n        const href = data.get('href');\n        return <a className={styles.link} {...props.attributes} rel=\"noopener noreferrer\" target=\"_blank\" href={href}>{props.children}</a>;\n      },\n      image: props => {\n        const {node, state} = props;\n        const isFocused = state.selection.hasEdgeIn(node);\n        const src = node.data.get('src');\n        return (<img data-hook=\"editor-image\" src={src} className={classNames(styles.editorImage, {[styles.activeEditorImage]: isFocused})}/>);\n      }\n    },\n    marks: {\n      bold: {\n        fontWeight: 'bold'\n      },\n      italic: {\n        fontStyle: 'italic'\n      },\n      underline: {\n        textDecoration: 'underline'\n      }\n    },\n    rules: [\n      // Rule to insert a paragraph block if the document is empty.\n      {\n        match: node => {\n          return node.kind === 'document';\n        },\n        validate: document => {\n          return document.nodes.size ? null : true;\n        },\n        normalize: (transform, document) => {\n          const block = Block.create(defaultBlock);\n          transform.insertNodeByKey(document.key, 0, block);\n        }\n      },\n      // Rule to insert a paragraph below a void node (the image) if that node is\n      // the last one in the document.\n      {\n        match: node => {\n          return node.kind === 'document';\n        },\n        validate: document => {\n          const lastNode = document.nodes.last();\n          return lastNode && lastNode.isVoid ? true : null;\n        },\n        normalize: (transform, document) => {\n          const block = Block.create(defaultBlock);\n          transform.insertNodeByKey(document.key, document.nodes.size, block);\n        }\n      }\n    ]\n  };\n  /* eslint-disable */\n\n  constructor(props) {\n    super(props);\n\n    const editorState = htmlSerializer.deserialize(props.value);\n    this.state = {\n      editorState,\n    };\n    this.lastValue = props.value;\n  }\n\n  componentWillReceiveProps(props) {\n    if (props.value && props.value !== this.props.value && props.value !== this.lastValue) {\n      const editorState = htmlSerializer.deserialize(props.value);\n      this.setState({editorState});\n    }\n  }\n\n  setEditorState = (editorState, isTextChanged = true) => {\n    this.setState({editorState}, () => this.triggerChange(isTextChanged));\n  };\n\n  triggerChange(isTextChanged = true) {\n    const serialized = htmlSerializer.serialize(this.state.editorState);\n    this.lastValue = serialized;\n    if (isTextChanged) {\n      const {onChange} = this.props;\n      onChange && onChange(serialized);\n    }\n  }\n\n  hasBlock = type => this.state.editorState.blocks.some(node => node.type == type);\n\n  hasListBlock = type => {\n    const {editorState} = this.state;\n    return editorState.blocks.some(node => {\n      const parent = editorState.document.getParent(node.key);\n      return parent && parent.type === type;\n    });\n  };\n\n  hasMark = type => this.state.editorState.marks.some(mark => mark.type == type);\n\n  hasLink = () => this.state.editorState.inlines.some(inline => inline.type === 'link');\n\n  handleButtonClick = (action, type) => {\n    switch (action) {\n      case 'mark':\n        return this.handleMarkButtonClick(type);\n      case 'block':\n        return this.handleBlockButtonClick(type);\n      case 'link':\n        return this.handleLinkButtonClick(type);\n      case 'image':\n        return this.handleImageButtonClick(type);\n    }\n  };\n\n  handleMarkButtonClick = type => {\n    const editorState = this.state.editorState\n      .transform()\n      .toggleMark(type)\n      .apply();\n\n    this.setEditorState(editorState);\n  };\n\n  handleImageButtonClick = type => {\n    this.props.onImageRequest(this.handleImageInput.bind(this));\n  }\n\n  handleImageInput = text => {\n    if (this.isValidImage(text)) {\n      const editorState = this.insertImage(this.state.editorState, text);\n      this.setEditorState(editorState);\n    }\n  }\n  onPaste = (e, data, state, editor) => {\n    switch (data.type) {\n      case 'text': return this.onPasteText(data.text, state)\n    }\n  }\n\n  onPasteText = (text, state) => {\n    if (this.isValidImage(text)) {\n      return this.insertImage(state, text);\n    }\n    return;\n  }\n\n  isValidImage = (text) => isUrl(text) && isImage(text);\n\n  insertImage = (state, src) => {\n    return state\n      .transform()\n      .insertBlock({\n        type: 'image',\n        isVoid: true,\n        data: { src }\n      })\n      .apply();\n  }\n\n  handleBlockButtonClick = type => {\n    let {editorState} = this.state;\n    let transform = editorState.transform();\n    const {document} = editorState;\n\n    // Handle everything but list buttons.\n    if (type !== 'unordered-list' && type !== 'ordered-list') {\n      const isActive = this.hasBlock(type);\n      const isList = this.hasBlock('list-item');\n\n      if (isList) {\n        transform\n          .setBlock(isActive ? '' : type)\n          .unwrapBlock('unordered-list')\n          .unwrapBlock('ordered-list');\n      }\n\n      else {\n        transform\n          .setBlock(isActive ? '' : type);\n      }\n    }\n\n    // Handle the extra wrapping required for list buttons.\n    else {\n      const isList = this.hasBlock('list-item');\n      const isType = editorState.blocks.some((block) => {\n        return !!document.getClosest(block.key, parent => parent.type == type);\n      });\n\n      if (isList && isType) {\n        transform\n          .setBlock(DEFAULT_NODE)\n          .unwrapBlock('unordered-list')\n          .unwrapBlock('ordered-list');\n      } else if (isList) {\n        transform\n          .unwrapBlock(type == 'unordered-list' ? 'ordered-list' : 'unordered-list')\n          .wrapBlock(type);\n      } else {\n        transform\n          .setBlock('list-item')\n          .wrapBlock(type);\n      }\n    }\n\n    editorState = transform.apply();\n    this.setState({editorState});\n  };\n\n  handleLinkButtonClick = ({href, text} = {}) => {\n    const {editorState} = this.state;\n    const transform = editorState.transform();\n    if (this.hasLink()) {\n      transform\n        .unwrapInline('link');\n    } else if (editorState.isExpanded) {\n      transform\n        .wrapInline({\n          type: 'link',\n          data: {href}\n        })\n        .focus()\n        .collapseToEnd()\n    } else {\n      const linkContent = text || href;\n      transform\n        .insertText(linkContent)\n        .extendBackward(linkContent.length)\n        .wrapInline({\n          type: 'link',\n          data: {href}\n        })\n        .focus()\n        .collapseToEnd();\n    }\n\n    this.setEditorState(transform.apply());\n  };\n\n  render = () => {\n    const {editorState} = this.state;\n    const {error, placeholder, disabled, resizable, onImageRequest, dataHook} = this.props;\n    const className = classNames(styles.container, {\n      [styles.withError]: error,\n      [styles.isFocused]: editorState.isFocused,\n    });\n    const isScrollable = resizable || this.props.maxHeight;\n\n    return (\n      <div className={className} data-hook={dataHook}>\n        <div className={classNames(styles.toolbar, {[styles.disabled]: disabled})}>\n          <RichTextEditorToolbar\n            disabled={disabled}\n            onClick={this.handleButtonClick}\n            onLinkButtonClick={this.handleLinkButtonClick}\n            onImageButtonClick={onImageRequest ? this.handleImageButtonClick : null }\n            hasMark={this.hasMark}\n            hasListBlock={this.hasListBlock}\n            hasLink={this.hasLink}\n            isSelectionExpanded={editorState.isExpanded}\n            />\n        </div>\n        <div\n          className={classNames(\n            styles.editorWrapper, {\n              [styles.resizable]: resizable,\n              [styles.scrollable]: isScrollable,\n              [styles.disabled]: disabled\n            })\n          }\n          data-hook=\"editor-wrapper\"\n          style={{maxHeight: this.props.maxHeight}}\n        >\n          <Editor\n            readOnly={disabled}\n            placeholder={placeholder}\n            placeholderClassName={styles.placeholder}\n            className={classNames(styles.editor, {[styles.disabled]: disabled})}\n            schema={this.schema}\n            state={editorState}\n            onPaste={this.onPaste}\n            onChange={e =>\n              {\n                const serialized = htmlSerializer.serialize(e);\n                const isValueChanged = serialized !== this.lastValue;\n                this.lastValue = serialized;\n                this.setEditorState(e, isValueChanged)\n              }\n            }/>\n          {this.renderError()}\n        </div>\n      </div>\n    );\n  };\n\n  renderError = () => {\n    const {errorMessage} = this.props;\n\n    return (\n      <Tooltip\n        disabled={!errorMessage}\n        placement=\"top\"\n        moveBy={{x: 2, y: 0}}\n        alignment=\"center\"\n        content={errorMessage}\n        theme=\"dark\"\n        >\n        <div className={styles.exclamation}><SvgExclamation width={2} height={11}/></div>\n      </Tooltip>\n    );\n  };\n}\n\nexport default RichTextArea;\n"}});